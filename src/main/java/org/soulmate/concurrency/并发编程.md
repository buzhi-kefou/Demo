线程状态
- 新建 new
- 可运行 runnable
- 阻塞 blocked
- 等待 waiting
- 计时等待 timed waiting
- 终止 terminated

死锁条件
- 互斥条件
- 保持与请求
- 不可剥夺
- 环路等待


## 基础知识

### 线程安全性
- 概念
- 原子性
- 加锁机制
- 状态保护
- 活跃性与性能

### 对象共享
- 可见性
- 发布与逸出
- 线程封闭
- 不变性
- 安全发布

### 对象组合
- 线程安全类
- 实例封闭
- 线程安全性委托
- 线程安全类扩展
- 同步策略文档化

### 基础构建模块
- 同步容器类
- 并发容器类
- 阻塞队列与生产者消费者
- 阻塞方法与中断方法
- 同步工具类


## 并发应用程序

### 任务执行
- 线程执行任务
- executor框架
- 可利用的并行性

### 取消与关闭
- 任务取消
- 基于线程服务停止
- 异常线程终止处理
- JVM关闭

### 线程池使用
- 任务与执行策略的隐形耦合
- 线程池大小
- 配置threadPoolExecutor
- 扩展threadPoolExecutor
- 并行递归算法

### 图形用户界面应用程序
- GUI单线程原因
- 短时间GUI任务
- 长时间GUI任务
- 共享数据模型
- 其他单线程子系统


## 活跃性、性能与测试

### 避免活跃性危险
- 死锁
- 避免与诊断
- 其他活跃性危险

### 性能与伸缩性
- 性能思考
- amdahl定律
- 线程引入开销
- 减少锁竞争
- 上下文切换开销

### 并发程序测试
- 正确性测试
- 性能测试
- 避免性能测试的陷阱
- 其他测试方法


## 高级主题

### 显示锁
- Lock与ReentrantLock
- 性能考虑因素
- 公平性
- synchronized与ReentrantLock
- 读写锁

### 构建自定义同步工具
- 状态依赖管理
- 条件队列
- 显示Condition
- synchronizer剖析
- AbstractQueuedSynchronizer
- concurrent同步器类重的AQS

### 原子变量与非阻塞同步
- 锁的劣势
- 硬件对并发的支持
- 原子变量类
- 非阻塞算法

### java内存模型
- 内存模型概念
- 发布
- 初始化安全性